<?xml version="1.0" encoding="UTF-8"?>
<shelfDocument>
  <!-- This file contains definitions of shelves, toolbars, and tools.
 It should not be hand-edited when it is being used by the application.
 Note, that two definitions of the same element are not allowed in
 a single file. -->

  <toolshelf name="accomplice_fx" label="Accomplice FX">
    <memberTool name="create_lop_nodes"/>
    <memberTool name="create_output_nulls"/>
    <memberTool name="add_missing_sublayers_to_main_fx_file"/>
    <memberTool name="add_missing_sublayers_to_multiple_main_fx_files"/>
    <memberTool name="configure_speedtree_leaves"/>
    <memberTool name="configure_speedtree_bark"/>
    <memberTool name="unlock_all_nodes"/>
    <memberTool name="open_fx_file"/>
    <memberTool name="render_movs_from_lighting"/>
  </toolshelf>

  <tool name="create_output_nulls" label="Create Output Nulls" icon="PLASMA_App">
    <script scriptType="python"><![CDATA[selected = hou.selectedNodes()
for selected_node in selected:
    outputs = selected_node.outputConnectors()

    for i in range(len(outputs)):
        null_node = selected_node.createOutputNode("null")
        null_node.setInput(0, selected_node, i)
        
        # Prompt the user for a name
        result = hou.ui.readInput("Enter a name for the null node (not including 'OUT_' prefix)")

        # The result is a tuple where the first item is the button clicked (0 for OK, 1 for Cancel) 
        # and the second item is the text entered by the user
        if result[0] == 0:
            null_node.setName("OUT_" + result[1].replace(" ", "_"), unique_name=True)
        
        null_node.setCurrent(True, clear_all_selected=True)
]]></script>
  </tool>

  <tool name="add_missing_sublayers_to_main_fx_file" label="Add Missing Sublayers to Main FX File" icon="PLASMA_App">
    <script scriptType="python"><![CDATA[
import hou
from pipe.shared.helper.utilities.houdini_utils import HoudiniFXUtils, HoudiniUtils

shot = HoudiniUtils.get_shot_for_file()
HoudiniFXUtils.insert_missing_cached_fx_into_main_fx_file(shot)
]]></script>
  </tool>

  <tool name="add_missing_sublayers_to_multiple_main_fx_files" label="Add Missing Sublayers to Multiple Main FX File" icon="PLASMA_App">
    <script scriptType="python"><![CDATA[
from pipe.shared.helper.utilities.houdini_utils import HoudiniFXUtils
HoudiniFXUtils.user_interface_for_resolving_missing_sublayers()
]]></script>
  </tool>

  <tool name="create_lop_nodes" label="Create Lop Nodes" icon="PLASMA_App">
    <script scriptType="python"><![CDATA[import hou
from pipe.shared.proxy import proxy
from pipe.shared.helper.utilities.houdini_utils import HoudiniFXUtils
from abc import ABC, abstractmethod

# Set constants

selection = hou.selectedNodes()
if len(selection) != 1:
    hou.ui.displayMessage(
        'Please select one null with the naming convention: "OUT_" + <name of effect>.',
        severity=hou.severityType.Message
    )
    raise Exception('Select only one node')

usd_wrapper = HoudiniFXUtils.USDGeometryCacheEffectWrapper(selection[0])
usd_wrapper.wrap()
hou.ui.setStatusMessage(
    'Lop nodes created successfully! Navigate to /stage to see the results.',
    severity=hou.severityType.Message
)]]></script>
  </tool>

  <tool name="configure_speedtree_bark" label="SpeedTree Bark" icon="PLASMA_App">
    <script scriptType="python"><![CDATA[import hou


# Get the currently selected node
selected_nodes = hou.selectedNodes()

# Check if a node is selected
if len(selected_nodes) > 0:
    for current_bark_geo_node in selected_nodes:
        assert current_bark_geo_node.type().name() == "geo", "The selected node is not a geo node."

        # Check if the child node is also a geo node
        vertex_cache_node = current_bark_geo_node.node('vertex_cache')
        assert vertex_cache_node is not None, "The current leaf geo node does not have a vertex_cache node."
        
        # Create an accomp_configure_bark node and connect it to the vertex cache node
        accomp_configure_bark_node = current_bark_geo_node.createNode("accomp_configure_bark")
        accomp_configure_bark_node.setInput(0, vertex_cache_node) 

        # Add an OUT_render null node and connect it to the accomp_configure_bark node
        out_render = accomp_configure_bark_node.createOutputNode("null", "OUT_render")

        out_render.setDisplayFlag(True)
        out_render.setRenderFlag(True)
        current_bark_geo_node.layoutChildren()
else:
    print("No nodes are selected.")]]></script>
  </tool>

  <tool name="configure_speedtree_leaves" label="SpeedTree Leaves" icon="PLASMA_App">
    <script scriptType="python"><![CDATA[import hou


# Get the currently selected node
selected_nodes = hou.selectedNodes()

# Check if a node is selected
if len(selected_nodes) > 0:
    for current_leaf_geo_node in selected_nodes:
        assert current_leaf_geo_node.type().name() == "geo", "The selected node is not a geo node."
        print(current_leaf_geo_node.name())

        # Check if the child node is also a geo node
        vertex_cache_node = current_leaf_geo_node.node('vertex_cache')
        assert vertex_cache_node is not None, "The current leaf geo node does not have a vertex_cache node."

        # the fbx import node is the input node into the vertex_cache node
        fbx_import_node = vertex_cache_node.inputs()[0]

        prepare_leaves_for_shading_node = current_leaf_geo_node.createNode("accomp_prepare_leaves_for_shading")

        # Create a null to preview the clusters from the prepare_leaves_for_shading node
        null_preview_clusters_node = current_leaf_geo_node.createNode("null", "OUT_preview_clusters")
        null_preview_clusters_node.setInput(0, prepare_leaves_for_shading_node, output_index=1)

        # place the prepare leaves for shading node between the fbx import node and the vertex cache node
        prepare_leaves_for_shading_node.setInput(0, fbx_import_node)
        vertex_cache_node.setInput(0, prepare_leaves_for_shading_node)

        # Create a scatter leaves on ground around tree node and connect it to the prepare leaves for shading node
        scatter_leaves_on_ground_around_tree_node = current_leaf_geo_node.createNode("scatter_leaves_on_ground_around_tree") # not prefixed with accomp because not specific to student accomplice workflow
        scatter_leaves_on_ground_around_tree_node.setInput(0, prepare_leaves_for_shading_node)

        # Create an animate leaves falling from tree node and connect it to the vertex cache node
        animate_leaves_falling_from_tree_node = current_leaf_geo_node.createNode("animate_leaves_falling_from_tree")
        animate_leaves_falling_from_tree_node.setInput(0, vertex_cache_node)

        # Merge the scatter leaves on ground around tree node and the animate leaves falling from tree node
        merge_node = current_leaf_geo_node.createNode("merge")
        merge_node.setInput(0, scatter_leaves_on_ground_around_tree_node)
        merge_node.setInput(1, animate_leaves_falling_from_tree_node)

        # Create a post process leaves node after the merge
        post_process_leaves_node = current_leaf_geo_node.createNode("accomp_post_process_leaves")
        post_process_leaves_node.setInput(0, merge_node)

        # Create two null nodes, one called OUT_render and connect it to the first input of the post process leaves node. The second one is called OUT_proxy and connect it to the second input of the post process leaves node.
        null_out_render_node = current_leaf_geo_node.createNode("null", "OUT_render")
        null_out_render_node.setInput(0, post_process_leaves_node)
        
        null_out_proxy_node = current_leaf_geo_node.createNode("null", "OUT_proxy")
        null_out_proxy_node.setInput(0, post_process_leaves_node, output_index=1)
        
        


        null_out_render_node.setDisplayFlag(True)
        null_out_render_node.setRenderFlag(True)
        current_leaf_geo_node.layoutChildren()
    
else:
    print("No nodes are selected.")]]></script>
  </tool>

  <tool name="unlock_all_nodes" label="Unlock All Nodes" icon="PLASMA_App">
    <script scriptType="python"><![CDATA[import hou


starting_node = hou.node('/')
print('Starting unlocking nodes!')

def unlock_all_chop_nodes(current_node):
    print("current node: " + current_node.name())
    try:
        if current_node.isLocked():
            current_node.setLocked(False)
            print("unlocked node: " + current_node.name())
    except Exception as e:
        # print(e)
        pass
    for node in current_node.children():
        unlock_all_chop_nodes(node)

def unlock_all_sop_nodes(current_node):
    try:
        if current_node.isHardLocked():
            current_node.setHardLocked(False)
            print("unlocked node: " + current_node.name())
    except Exception as e:
        # print(e)
        pass
    for node in current_node.children():
        unlock_all_sop_nodes(node)

unlock_all_chop_nodes(starting_node)
unlock_all_sop_nodes(starting_node)

print('All nodes unlocked')]]></script>
  </tool>

  <tool name="open_fx_file" label="Open FX File" icon="PLASMA_App">
    <script scriptType="python"><![CDATA[from pipe.shared.helper.utilities.houdini_utils import HoudiniFXUtils

HoudiniFXUtils.open_houdini_fx_file()
]]></script>
  </tool>

  <tool name="render_movs_from_lighting" label="Render MOVs from Lighting" icon="PLASMA_App">
    <script scriptType="python"><![CDATA[
import hou
import pipe
from pipe.shared.helper.utilities.houdini_utils import HoudiniUtils, HoudiniNodeUtils, HoudiniPathUtils
import datetime
import os
from pipe.shared import Shot
from pipe.shared.helper.utilities.ui_utils import ListWithCheckboxFilter

def operation():
    submit_for_real = True
    stage = hou.node('/stage')
    shot = HoudiniUtils.get_shot_for_file()
    print(shot.name)
    shot_usd_path = shot.get_shot_usd_path()
    date_string = datetime.datetime.now().strftime('%m-%d-%Y')
    destination_path = os.path.join(shot.get_shotfile_folder('fx'), 'render', date_string)
    # if the destination path doesn't exist, create it, including any parent directories
    if not os.path.exists(destination_path):
        os.makedirs(destination_path, exist_ok=True)

    # shot_rop_node = HoudiniNodeUtils.find_first_node_with_parm_value(stage, 'usd_rop', 'lopoutput', shot_usd_path)

    # insert the accomp motion blur node before the shot_rop_node
    end_lighting_node = hou.node('/stage/END_lighting')
    motion_blur_node = end_lighting_node.createOutputNode('accomp_motion_blur')



    stage.layoutChildren()

    # After it finishes "ropping" make a new tractor submit node
    tractor_node = motion_blur_node.createOutputNode('tractor_submit')

    stage.layoutChildren()

    # Set the title to be the name + MotionBlurTest + the date in two digits (e.g., for February 3, it would be 2-3-2024)
    tractor_node.parm('jobtitle').set(shot.name + ' Beauty Submission from FX Convenience Shelf ' + date_string)
    tractor_node.parm('createplayblasts').set(1)
    tractor_node.parm('ui_notify_on_job_submission').set(0)
    tractor_node.parm('sourceoptions11').set(1)
    tractor_node.parm('nodecamera1').set(HoudiniPathUtils.get_camera_prim_path(shot))
    tractor_node.parm('layername1_1').set("Beauty")
    tractor_node.parm('denoise').set(0)
    tractor_node.parm('nodeoutputpath1').set(destination_path + '/frame.$F4.exr')
    tractor_node.node('hdprmanrendersettings1').parm('xn__driverparametersopenexrasrgba_bobkh').set(0)

    if submit_for_real:
        tractor_node.parm('submit').pressButton()

all_shots = pipe.server.get_shot_list()
shot_selector = ListWithCheckboxFilter("Select Shots To Render Preview Renders For", all_shots)

missing_shots = []
errored_shots = []
error_messages = []

if shot_selector.exec_():
    selected_shots = shot_selector.get_selected_items()
    selected_shots = [Shot(shot) for shot in selected_shots]

    for shot in selected_shots:
        lighting_file_path = shot.get_shotfile('lighting')
        if not os.path.exists(lighting_file_path):
            missing_shots.append(shot.name)
            continue
        try:
            HoudiniUtils.perform_operation_on_houdini_file(
                lighting_file_path,
                False,
                operation
            )
            print("Completed operation on shot " + shot.name)
        except Exception as e:
            errored_shots.append(shot.name)
            error_messages.append(str(e))

print("These are the missing shots " + str(missing_shots))
print("These are the errored shots " + str(list(zip(errored_shots, error_messages))))]]></script>
  </tool>
</shelfDocument>
